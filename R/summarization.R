#' Extract the salient results from an ept mod
#' 
#' @param ept_mod The ept_mod
#' @param tree The tree of interest
#' @param leaf_sds SDs used in scaling leaf volumes
#' @return A list containing
#' 1. `fix` The fixed effects of the model
#' 2. `effects` The estimated median effects in the model
#' 3. `ranints` The estimated random intercepts from the model
#' 4. `b_post` The effect posterior samples
#' @export
get_ept_results <-
  function(ept_mod, tree, sds){
    nodes <- tree$Get("name")
    post <- extract(ept_mod)$b[ , order(nodes), 2]
    colnames(post) <- sort(nodes)

    b_fix <-
      extract(ept_mod)$b_fix %>% apply(2, median)
    
    scaled_post <- t(t(post + b_fix[2]) * sds)

    raw_effects <-
      apply(post[,nodes], 2, median) 

    scaled_effects <-
      apply(scaled_post[,nodes], 2, median)

    ranints <-
      extract(ept_mod) %>%
      .$ranints %>%
      apply(2,median) %>%
      `*`(mean(sds))

    list(fix = b_fix
       , effects = scaled_effects
       , raw_effects = raw_effects
       , ranints = ranints
       , b_post = post
       , scaled_post = scaled_post)
  }

#' Extract the salient results from an stan_glmer model
#' 
#' @param smod The [stan_glmer] model
#' @param tree The tree of interest
#' @param leaf_sds SDs used in scaling leaf volumes
#' @return A list containing
#' 1. `fix` The fixed effects of the model
#' 2. `effects` The estimated median effects in the model
#' 3. `ranints` The estimated random intercepts from the model
#' 4. `b_post` The effect posterior samples
#' @export
get_sglm_results <-
  function(smod, tree, sds){
    nodes <- tree$Get("name")
    post <- as.matrix(smod)
    cols <- colnames(post)
    effect_cols <- sapply(nodes, function(n){
      n %>%
        gsub("([().])", "\\\\\\1", .) %>%
        gsub(" ", "_", .) %>% { grep(paste0("b\\[SEX.*name:", ., "]"), cols) }
    })

    b_post <- post[,effect_cols]
    fix <- post[ , c("(Intercept)","SEX")] %>% apply(2, median)
    colnames(b_post) <- nodes

    scaled_post <- t(t(b_post + fix[2]) * (sds))

    raw_effects <- 
      b_post %>%
      apply(2, median) 

    scaled_effects <-
      scaled_post %>% apply(2, median)

    ranints <- as.numeric(ranef(smod)$ID[,1])
   
    list(fix = fix
       , effects = scaled_effects
       , raw_effects = raw_effects
       , ranints = ranints
       , b_post = b_post
       , scaled_post = scaled_post)
  }

#' Compute the likelihood for a tree model
#'
#' @param mod A stan model with at least `y_pred`
#' and `sigma_model`
#' @param y The y data
#' @return A matrix with the same dimensions as
#' `extract(mod, "y_pred")[[1]]` i.e. samples x obs
#' containing the gaussian likelihood of each
#' y_pred sample.
#' @export
logLik_ept <- function(mod, y){
  y_pred <- extract(mod, "y_pred")[[1]]
  sigma <- extract(mod, "sigma_model")[[1]]

  t(sapply(seq_len(nrow(y_pred)),
         function(i) log(dnorm(y - y_pred[i,], sd = sigma[i]))))
}

#' Get the fitted value from an ept model
#'
#' @param ept The ept model of interest
#' @return A n-vector of median fitted values
#' @export
fitted_ept <- function(ept) apply(extract(ept)$y_pred, 2, median)

#' Effect areas
#'
#' Create a posterior plot for the parameters with true effects
#' from results generated by `get_sglm_results` and `get_ept_results`
#'
#' @param results The result object of interest
#' @param effects The simulated effects
#' @param sds The node sds
#' @param tree The source tree
#' @return a ggplot object
#' @export
effect_areas <- function(results, effects, sds, tree){
  nodes <- tree$Get("name")
  
  scaled_effects <-
    effects[nodes] %>%
    `/`(sds[nodes]) %>%
    { data_frame(param = names(.), eff = .) }

  post <- results$b_post[,nodes] + results$fix[2]

  as <- mcmc_areas(post)

  as_data_u <-
    as$data %>%
    group_by(parameter) %>%
    slice(1) %>%
    ungroup %>%
    mutate(ymin = as.numeric(order(parameter, decreasing = TRUE))
         , ymax = ymin + .9
         , param = as.character(parameter)) %>%
    inner_join(scaled_effects, by = "param")

  as +
    geom_segment(aes(y = ymin, yend = ymax, x = eff, xend = eff)
               , col = "red", data = as_data_u) +
    scale_x_continuous()
}


#' Effect likelihoods
#'
#' Compute the likelihood of the simulated parameters given the models
#' 
#' @param results The result object of interest
#' @param effects The simulated effects
#' @param sds The node sds
#' @param tree The source tree
#' @return A vector of pointwise likelihoods for each parameter
#' @export
pw_effect_loglik <- function(results, effects, sds, tree){
  scaled_effects <-
    effects %>%
    `/`(sds) %>%
    { data.frame(parameter = names(.), eff = .) }

  nodes <- tree$Get("name")
  post <- results$b_post[,nodes] + results$fix[2]

  gauss_approx <-
    apply(post, 2, function(col) c(mean = mean(col), sd = sd(col)))

  imap_dbl(scaled_effects$eff
         , ~ log(.Machine$double.eps +
                 dnorm(.x, mean = gauss_approx[1, .y], sd = gauss_approx[2, .y])))
}

#' Compute the difference in beta between parent and child
#'
#' Add the posterior for the estimated effects back to a tree
#' then compute the difference between parent and child.
#'
#' @param results The result object of interest, must have b_post
#' and fix elements.
#' @param tree The hierarchy tree of interest
#' @return tree modified with extra node attributes b_post and b_diff
#' @export
compute_differences <-
  function(results, tree){
    ex_tree <- Clone(tree)

    ex_tree$Do(function(n) n$b_post <- results$b_post[,n$name])
    ex_tree$Do(function(n){
      if(is.null(n$parent)){
        n$b_diff <- n$b_post
      } else {
        n$b_diff <- n$b_post - n$parent$b_post
      }
    })
    
    ex_tree  
  }
